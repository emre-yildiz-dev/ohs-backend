# Internationalization (i18n) System

This document describes the Fluent-based internationalization system implemented for the OHS Backend.

## Overview

The i18n system provides:
- Support for Turkish (default) and English languages
- Fluent-based translation system with advanced features
- Automatic language detection from HTTP headers
- Easy-to-use extractors for Axum handlers
- API endpoints for client-side integration

## Architecture

### Core Components

1. **Language Support** (`src/i18n/language.rs`)
   - `SupportedLanguage` enum with Turkish and English
   - Language detection from Accept-Language headers
   - Language identifier mapping for Fluent

2. **Fluent Loader** (`src/i18n/fluent_loader.rs`)
   - Loads FTL (Fluent Translation List) files
   - Manages Fluent bundles for each language
   - Auto-creates default translation files

3. **Localizer** (`src/i18n/localizer.rs`)
   - Main interface for getting translations
   - Supports arguments and fallback languages
   - Thread-safe and async-compatible

4. **Helpers** (`src/i18n/helpers.rs`)
   - `I18n` extractor for easy use in handlers
   - Helper macros for creating arguments

5. **Middleware** (`src/middleware/language.rs`)
   - Detects language from headers
   - Adds language to request extensions

## Usage

### In Axum Handlers

```rust
use crate::i18n::I18n;
use crate::i18n_args;

async fn my_handler(i18n: I18n) -> Json<MyResponse> {
    // Simple translation
    let message = i18n.get("welcome");
    
    // Translation with arguments
    let args = i18n_args! {
        "name" => "John",
        "count" => 42
    };
    let personalized = i18n.get_with_args("user-greeting", &args);
    
    Json(MyResponse { message, personalized })
}
```

### Language Detection

The system detects language in this priority order:
1. `X-Language` header (explicit setting)
2. `Accept-Language` header (browser preference)
3. Default to Turkish

### API Endpoints

- `GET /api/i18n/languages` - Get supported languages
- `GET /api/i18n/translations?keys=key1,key2&language=en` - Get translations
- `GET /api/i18n/current-language` - Get current detected language
- `GET /api/i18n/example` - Example localized response

## Translation Files

Translation files are stored in `locales/{language_code}/` directories:

```
locales/
├── tr/
│   └── common.ftl
└── en/
    └── common.ftl
```

### FTL Syntax Examples

```fluent
# Simple message
welcome = Hoş geldiniz!

# Message with variables
user-greeting = Merhaba, { $name }!

# Message with pluralization
item-count = { $count ->
    [0] Hiç öğe yok
    [1] 1 öğe
   *[other] { $count } öğe
}

# Terms (reusable)
-brand-name = İSG Sistemi
app-title = { -brand-name } - Ana Sayfa
```

## Configuration

### Adding New Languages

1. Add the language to `SupportedLanguage` enum
2. Update language detection logic
3. Create translation files in `locales/{code}/`
4. Update language identifier mapping

### Adding New Translation Keys

1. Add keys to all language files
2. Use descriptive, hierarchical naming:
   - `auth-login` for authentication login
   - `error-validation` for validation errors
   - `success-created` for creation success

## Client Integration

### JavaScript Example

```javascript
// Get translations for current language
const response = await fetch('/api/i18n/translations?keys=welcome,login,logout');
const { translations, language } = await response.json();

// Use translations
document.getElementById('welcome').textContent = translations.welcome;

// Set language preference
fetch('/api/endpoint', {
    headers: {
        'X-Language': 'en'
    }
});
```

### React Example

```jsx
const useTranslations = (keys) => {
    const [translations, setTranslations] = useState({});
    
    useEffect(() => {
        fetch(`/api/i18n/translations?keys=${keys.join(',')}`)
            .then(res => res.json())
            .then(data => setTranslations(data.translations));
    }, [keys]);
    
    return translations;
};

function MyComponent() {
    const t = useTranslations(['welcome', 'login', 'logout']);
    
    return (
        <div>
            <h1>{t.welcome}</h1>
            <button>{t.login}</button>
        </div>
    );
}
```

## Best Practices

1. **Key Naming**: Use kebab-case with hierarchical structure
   - `user-profile-edit`
   - `error-network-timeout`

2. **Arguments**: Use descriptive argument names
   - `{ $userName }` instead of `{ $name }`
   - `{ $itemCount }` instead of `{ $count }`

3. **Fallbacks**: Always provide fallback text for missing translations

4. **Performance**: Cache translations on the client side

5. **Testing**: Test with different languages and missing keys

## Error Handling

The system gracefully handles:
- Missing translation files (creates defaults)
- Missing translation keys (returns key as fallback)
- Invalid language codes (falls back to default)
- Fluent syntax errors (logs warnings)

## Development

### Adding New Modules

When adding new modules, create dedicated FTL files:

```
locales/
├── tr/
│   ├── common.ftl
│   ├── auth.ftl
│   └── training.ftl
└── en/
    ├── common.ftl
    ├── auth.ftl
    └── training.ftl
```

### Testing Translations

Use the example endpoints to test translations:

```bash
# Test Turkish (default)
curl http://localhost:3000/api/i18n/example

# Test English
curl -H "Accept-Language: en" http://localhost:3000/api/i18n/example

# Test explicit language
curl -H "X-Language: en" http://localhost:3000/api/i18n/example
```

## Troubleshooting

### Common Issues

1. **Missing translations**: Check FTL file syntax and key names
2. **Language not detected**: Verify header format and middleware setup
3. **Arguments not working**: Check Fluent syntax and argument names
4. **Performance issues**: Consider caching and bundle optimization

### Debug Mode

Enable debug logging to see translation loading and errors:

```bash
RUST_LOG=ohs_backend::i18n=debug cargo run
``` 